# Java web application development review
_Exported on 7/1/2025 at 15:24:27 GMT+9 from Cursor (1.1.6)_

---

**User**

250626
	어제 배웠던 핵심
	전달의 개요를 잘 알지
		메뉴를 통한 구조도와 현재 작업 파악하기
	계속 쓰이는 패턴을 외우자
		
	1교시 복습
		ㄷㄹ컨트롤러가 받는 요청드들
			기능이 없으니까 서비스한테서 빌린다
"서비스야, 나 전달할 거 있으니까 너도 나한테 전달해줄래?" 
		병렬처리
			기존에는 todoDTO에서는 반복문을 통해서 DAO를 받은 모델클래스들을 반환해주고 있었다.
리스트는 순서가 있으니까. 해당 VO를 가지고 오고 모델매퍼로 변환하고, 결론은 vo를 DTO로 바꿨씁니다.
			이거를 빌드처럼 해서 병렬처리를 할 수가 있는데요. 스트림이랑 해당 메서드가 있는데요. 해당 리스트 기능 중 하나입니다.

스트림은 병렬처리하겠다. 맵은 내장 기능 중 하나인데요
				맵은 이런 겁니다. 남자 1번이 여자 1번을 가리킵니다. 이건 가리킨다고 해서 매핑이라고 합니다.

이건 VO라는 클래스에 있는 멤버로 DTO에 있는 멤버를 가리키는 겁니다. 맵이라는 건 대응하다 가리키다 라는 뜻이 있는데 하나와 하나가 연결된다는 거죠.

리스트는 요소를 여러개 가지지 않습니까? 전체목록인데 todoDTO라는 모델클래스라는 걸로 구성되어있습니다. 그래서 만약에 10개가 안에 있다면 10번 작업을 한다고 보시면 됩니다.

vo리스트의 전체를 순회하면서 다 바꿔줍니다.   이걸 보통 중간처리라고 합니다.
				이렇게 일을 하면서 어떻게 처리하고 있죠? 바꾸고, 컬렉트 리스트에 리스트화 시키고 있죠. 이런 걸 '병렬 처리'라고 하는데 좋은 질문이라서 답을 해드렸습니다.
				위의 것과 기능 자체는 똑같습니다.
	2교시
		등록폼
			스크립트
				사이클
					방금 url로 직접 들어가서 요청을 했죠.
그림판에서 보여드렸던 것 기억나십니까? 화면에서 요청했으니 컨트롤러 서비스 dao db로 가죠. 근데 얘가 요청한 건 '화면만' 요청한 거예요. 그러니까 DB까지 갈 필요가 있을까요? 없는 거죠. 컨트롤러가 갈 뷰가 있었잖아요. 그래서 여기까지만 가고 요청에 응답합니다.

					가령 날짜를 등록한다고 하면 포스트작업이죠. 컨트롤러한테 전달하죠. 서비스에서 dao 가 직접 db를 쓰죠. 쓰고 나니까 결과가 리턴으로 돌아오겠죠. 이게 1번이죠.
					그럼 2번 컨트롤러는 다시 또 전체조회를 위해서 또 싸이클을 돌리게 됩니다. 리다이렉트를 해서 화면을 전달해줘야하니까 RPG 패턴을 써줘야 하는 거죠.
					조회든 삭제든 이런 싸이클을 스스로 한번 그려보는 것이 도움이 된다. 두세번만 해보면 전체 흐름을 파악할 수 있다.
				상세조회
					자 일단 하나조회를 한번 해보게씁니다. 퍼블릭 투두 롱 tno 써주고 쓰로우즈라고 해서 익셉션 한번 쓰겠슨다. 그럼 해당 게시글 번호를 받아 조회를 하겠습니다. 현재 위치는 서비스죠.
						얘는 직접적으로 DB 조회 안 되죠. 직접 기능을 만들기보다는 불러와 써야겠죠.  일단 기록을 좀 남기겠습니다. 로그 인포 Todo서비스에서 하나 조회 기능 작업입니다.(나중에 에러 파악해야죠)
dao.셀렉트 원이라고 해서 화면 tno 번호를 넘겨주고 db 조회번호를 넘겨주면 어떻게 되냐면 todovo 로 바뀌게 됩니다. 이거 동의합니까?

							이거 받은 vo 를 DTO로 변환한다고 했죠. 모델맵퍼 쓰면 되겠죠. 
							투두DTO를 반환하니까. 리턴까지
							만들고 나면 기능 단위 테스트를 해야겠죠
					단위 테스트도 당연히 해야겠죠.
하나 조회 기능입니다. 실제 조회할 db 데이터를 이제 파악을 해야합니다. 없는 DB 조회하면 안되니까요. 
						확인해보면 이렇게 있는데 임의로 14번 한번 조회해볼게요.
						뭐할 거냐면 투두서비스라고 했으니까 투두서비스의 겟바이tno 14번으로 하고, 리턴을 뭘라 받냐면 TodoDTO로 받으면 됩니다. 
그리고 여기에 로그 인포로 기록 남기죠. 확인하는 거랑 전달된 거.
				조회(투두 리드 컨트롤러)
					메모 10번을 보면 조회니까 투두 리드, 조회화면 jsp 이용해볼게요 
						자 이제 컨트롤러 가서 새로 만들기 해보겠습니다.
하나만 들고요.
							반복되는 작업이긴 한데 당분간 쓰겠습니다.
임포트 웹 서블릿하고 상속 받아주시고 앞에 소문자로 바꾸고 이름 동일하게 안 하고 2번 url 패턴도 투두리드 2번 하겠습니다 겹치면 안되니까. 

로그 기록도해야하니까 log4j2도 해주시고요 
							컨트롤러는 조회가 본인 기능이 없으니까, 투두서비스에 인스턴스 하시면 됩니다
							그리고 일단은 하나 조회를 해야하기 때문에 오게 틀이라는 게 점점 보이실 겁니다.
							이게 틀이란 게 점점 보일 겁니다 이름만 바뀌고 있죠
					이제 작업을 할게요 트라이캐치를 할게요. 비정상적인 작업이 발생하면 안 되니까요. 에러가 발생하면 어떻게 할지 해두고, 요것도 틀이라고 보심 됩니다
						이제 요기다 화면에서 전달받은 tno번호를 이용해서 서비스에 하나 조회 요청하기 햅겠습니다. 

이걸 어떻게 받을 계획이냐면?

1)화면에서 쿼리 스트링 형식으로 전달받을 겁니다. 앞에서 배우셨던 /todo/read2?tno=20 이런 식으로 물음표와 나오는 방식으로요. 이러면 무조건 문자열로 넘어오는 특징이 있답니다. 그럼 로그를 문자열로 반환해주면 되죠. 이 작업을 할 겁니다.
							화면에서 문자열로 넘어오는 작업을 할 거니까 겟 파라미터로 tno라는 키를 해당하는 값을 주세요, 라고 하고 얘는 받아야할 거잖습니까.

롱. 파스롱 해서 문자열을 집어넣어주면 됩니다. 

							결과값 타입은 문자열인데, 문자열이 들어오면 변환하는 거 겟 파라미터는 tno 키에 대해서 2라는 문자를 줍니다. 
							자 이제 번호받았으니까 서비스한테 요청하면 되죠. 투두에 겟바이 티엔오 하심 되죠
받아온 데이터는 TodoDTO 타입이 되니까 여기에 써주시면 되겠죠
								이제 데이터를 화면에 탑재해야죠. 키는 dto, 값은 todoDTO.
									받았으니까 화면에 전달해야겠죠
									읽기 전용 화면은 여기로 할 겁니다. 메모한 것에 약속되어 있는 곳이죠. 만약에 기존에 todoREAD가 있다고 하면... 있네요 2번이라고 만들겠습니다.
									이번에 뭘 했냐면 하나 조회 서비스 기능인데요

"컨트롤러에서 DB를 받고, 화면에서 tno 번호 쿼리 스트링으로 받고, tno 번호로 서비스에 하나 조회 요청하고, 받은 데이터를 화면에 탑재하고, 화면에 전달하기"
					작업 흐름
정확하진 않지만 그냥 비교뵤
						하위 주제 1
							하위 주제 1
								하위 주제 1
				JSP 삭업
					자 이제 jsp 작업을 해보겠습니다. todread2번 파일을 하나만들 거고요.
						지금은 html 뼈대만 간단하게 작업을 하겠습니다. 간단한 작업이니까 반복이지만 그냥 해볼게요. 중요한 건 밸류부분 JSTL 표기법으로 서버로부터 넘어온 dto.객체 안에서 리드온리로 작업을 하겠습니다.
							갑자기 이게 왜 뜬금없이 나왔냐하면 컨트롤러에서 화면쪽으로 데이터를 전달했는데요. 서버에서 dto라는 이름으로 요렇게 전달을 했어요
							어디를 확인하냐면 컨트롤러에 보면 키값이 나오죠. 그래서 요렇게 작업을 한 겁니다.
							이번엔 tno 말고 타이틀 받아올 거고요.
날짜는 타입이 데이트니까 듀데이트. 체크박스까지 작업을 해보았답니다
								피니쉬드는 잘 보셔야할게 피니쉬가 존재를 하면 뭘로 표기할 거냐면 체크 속성을 쓸거고 트루가 아니라면 빈 옵션을 쓸 겁니다. ? : "" 요렇게 했죠
								여기서 만들진 않았지만 수정하거나 할 때는 요기로 가게 해야겠죠. 업데이트 폼이고요. tno라고 해서 받았던 값을 달러 중괄호 dto.tno 로 전달할 거고, 간단하게 수정폼이라고 쓸게요
								수정폼에 삭제도 작업을 해두겠습니다.
									수정한 부분이 있었습니다. 체크 박스는 걍 체크하면 체크되는 기능이라 밸류는 필요가 없었죠
					하나 조회화면을 목록 리스트에 a 태그 이용해서 링크로 겟 방식으로 쿼리스트링의 파라미터로 전달하기 작업
						조회를 해볼 건데 원래 기존엔 dto라고 해서 데이터를 한번에 출력했었죠. 이제 todolist.jsp에서 나눠서 작업을 해보도록 하겠습니다.
							조회하면 어디로 갈 거냐면 todo/read2?tno=""로 번호를 전달할 건데 번호는 이미 목록에 dto란 곳에 tno 번호를 가지고 있으니 이걸 전달하시면 되고요. 여기에다가도 달러 중괄호 해서 dto tno 하겠습니다. 보안상 하는 것도 있지만 일단 연습용으로요
							나머지 예를 들어서 스팬이라고도 하고 제목도 쓰겠습니다 달러 중괄호 타이틀도 꺼내 쓸 거고요. 두데이트도 꺼내쓰고 할 겁니다.
							오류난 예외 제목 수정해주시고요.
								그럼 요렇게 데이터가 잘 나오게 됩니다.
그런데 요기서 눌렀을 때 잘 가는지를 확인해봐야하죠 겟방식으로
								
								요기다가 글쓰기 버튼도 똑같은 방식으로 한번 넣어보겠습니다. 화면으로 가면 무조건 겟입니다.
							(중요)오류가 난 화면을 수집하듯이 해서 수정할 줄 아는 것도 아주 귀중한 덕목
	3교시
		삭제 서비스, 컨트롤러에 연결하기, 화면에서도 연결 확인
			삭제는 어차피 서비스가 하지 않고 DAO에서 하죠.
그래서 가져올 겁니다. 반복되는 부분은 복사해주시고
			요렇게 삭제니까 맞는 이름으로 바꿔주시면 되겠죠. 실제로 삭제할 tno 번호를 파악을 해야겠죠. 
그리고 삭제만 할 거니까 받는 게 필요가 없습니다. 10번을 삭제해보는 걸로 할게요
			서비스 단위 테스트에서 삭제확인하고요.. 이제 삭제 버튼도 기능작업을 했으니 추가하러 갑시다. 컨트롤러로 이동해가서 작업을 할게요.
				삭제하는 쪽에 가 보시면 투두딜리트 컨트롤러라고 요렇게 만들었습니다. 
				삭제를 할 때 포스트에 딜리트라고 쓰고 포스트 처리할 예정입니다. 작업을 해볼게요.
				그 담에 삭제할 번호를 가져와야겠죠. 하나 조회하는 방식과 동일하답니다. 먼저 받아와야하니까 리퀘스트 겟 파라미터라고 해서 받아올 건 tno라는 번호를 받아오면 됩니다. 근데 이건 문자열이니까, 숫자형태로 파싱이 필요하죠. 롱 파시롱해서 감아주시면 됩니다. 방금 식은 하나조회와 동일하기에 복사하셔도 됩니다
					넘어온 번호를 확인하기 위해서 log 확인 기록 해주시고, 작업을 한다는 걸 위치를 남겨놓는 것입니다.
					그리고 트라이 캐치로 예외 발생하면 왜 나는지 메시지 나타나게 하고요. 이게 하나 틀이고요.
					그리고 실제 삭제 처리는 투두 서비스에다가 리무브로 요청하면 되죠
						PRG 패턴이니까 리다이렉팅은 리스트로 보내야겠죠. 리다이렉트? 어디로 todo 리스트 2번으로
						자 그럼 삭제하는 곳에다가 이걸 걸어주시면 되거든요. (2번 들어가야 함)
						투두 리드 2번이니까 요기로 와서 해보겠습니다. 삭제 버튼이 여기 있거든요. 만들어놓은 곳을 호출하게 되면, 컨트롤러 와서, 삭제 처리하고 리스트로 가게 되는 형식입ㄴ다
						아 그리고 우리는 포스트 방식으로 할 거니까 따로 작업을 한번 하겠습니다. 폼으로 전달하는 거 몇번 보여드렸는데요
							액션으로 해서 어디로 보낼 거냐면 todo/delete2로, 포스트로 보낼게요
							앞에선 삭제할 때 번호로 보냈지만, 저희가 이번에는 html 쓸 때 썼던 hidden을 이용할게요. 이름은 tno 하고 값은 dto.tno 하겠습니다. 수정 안되게 리드 온리. 그리고 버튼까지 완료. 수정은 아직 미구현이고요.
	4교시
		수정 작업
			이제 삭제해봤으니까 수정을 위해서 바로 서비스 가볼게요. 수정기능.
			수정 기능이니까 퍼블릭에 제 맘대로 업데이트라고 할까요? modify도 괜찮으니까 그걸로. 수정할 데이터들을 화면에서 받아와야하니까 TodoDTO todoDTO로 받아오시고, log.info(투두 서비스에서 작업하고 있고요. 기록남겨뒀답니다.)
			자 DTO에서 넘어왔던 걸 VO로 바꿔줘야합니다. 그리고 실제로 DAO에게 변경된 데이터를 전달하며 요청해줘야합니다. 이게 수정 기능의 다입니다
				단위테스트는 투두서비스테스트입니다. 삭제라고 된 걸 복사해서 거의 그대로 쓸게요. 
				
				일단 수정할 DB를 파악을 해야하겠죠. 자, 그러면 투두 서비스에서 한명을 조회할 수 있거든요? 겟바이로 해서. 몇번 확인할 거냐면, 저 같은 경우 14번이라고 할게요. 14번 이렇게 쓰시면 14번 데이터를 투두 DTO로 가져오게 됩니다.
					가지고 온 걸 아까 모디파이, 수정하는 곳에다가 넣어주면 됩니다
					그리고 변경할 데이터를 잘 가져왔는지 확인도 해야하니까 로그 인포도 써주시고요
					대이터 가져오고, 변경할 내용도 작업을 해보았답니다. 단위 테스트할 수 있게.
						자 위치는 계속해서 서비스 보시는 것처럼 기능 만들고, 기능 만들었으니까 단위 테스트하고, 서비스 만든 걸 컨트롤러에 작업하러 갈게요
						메모 10번에 보면 구조 명세서가 여기에 나와있죠. 수정 화면, 로직 처리 요렇게 2개가 필요하니까 일단 컨트롤러 만들어보겠습니다. 요기서는 2개가 겟과 포스트 다 있답니다.
						컨트롤러 만들었고요 상속받고 , 웹서블릿 작업하시고 네임 만들어서 이름은 투두 업데이트 하고 소문자로 바꿔주시고 2번 넣고, url 패턴에 주소는 명세서에 나온 것처럼 업데이트로 한다고 했습니다. 복사해서 넣어주시고요 일부러 2번이라고 할게요. 
							만들었으니까 2가지 할게요 수정폼 두겟과 로직처리 두포스트가 필요하죠. 이걸 차근차근 해볼게요. 일단 두겟이랑 두포스트 작업할 거구요. 컨트롤러는 기능이 없어 의존해야하니까 서비스 기능 가져오는 작업부터 할게요.
							담에 수정하는 폼에서 데이터 만들어야 하니깐요. 포매터 그대로 만들어주시고 시간은 없이 연월일까지만으로요.
							서비스 도움 받아야 하니까 객체도 필요하니까 가져왔고, 양식도 해당 문자열을 데이트 포맷으로 바꿔준 거죠.다음으로 두겟 작업도 할게요
					두겟 작업
						두겟 작업입니다. 반복되는 틀 해주시고 그 다음에는 다들 아시죠.  만약 에러 없으면 롬복 넣어주시면 되고
							런타임 익셉션이든 서블릿 익셉션 하셔도 되고, 어차피 하위라 상관이 없답니다. 예외는 수정 폼 조회 에러라고 한번 써놓도록 할게요
							자 그러면 저희는 어떻게 할 예정이냐면요.
수정할 tno 번호를 이용을 해서 수정 폼 화면으로 하나의 정보를 조회해서 화면에 보내기 할 게요
							수정할 정보는 쿼리 스트링으로 넘어오니까 겟 파라미터해서 똑같이 tno로 조회하고 문자열이기 때문에 롱에 파스롱이라고 해서 '문자열을 롱파스로 해서 숫자형태로 바꿔주시게 합니다. 이걸 재사용하기 위해 = long tno 임시변수에 넣어두겠죠
								저희는 이제 하나 정보 조회를 tno 번호 이용해서 할게요. 이거 타입에 맞게 받아주시면 되고요
								받았으니까 이제 수정폼에 하나 조회한 정보를 전달하면 되겠죠. 화면에 데이터 전달. 저희는 리퀘스트에 셋 어트리뷰트라고 해서 dto란 이름으로 투두디티오를 이런 식으로 작성할게요
								이제 데이터 화면에 전달하면 되겠죠 리퀘스트 겟 리퀘스트 디스패쳐. 이용해서 전달할 위치는요. 웹 인포에 투두에 화면은 무러로 하기로 했냐면 명세서에 todoUpd 라고 했었는데 걍 헷갈리니까 Updatate 라고 하고 다 쓸게요. todoUpdate.jsp 로 보내고
								화면이 없으니까 업데이트 jsp 화면 만들어주시고요. 
									계획
										여기는 임시 수정폼 화면이라고 기재해두도록 하겠습니다. tno로 데이터 조회해서 일단 불러오기. 그리고 수정할 내용 변경해서 다시 post로 전달하기
									수정을 하기로 했으니까 작업을 일단 하겠습니다. 투두 리드2와 내용이 거의 동일하니까 그냥 복붙을 하도록 하겠습니다.
									그리고 하나씩 확인을 해볼게요. 일단 수정폼 화면을 불러오는 걸 했으니까, post로 전달하기 위해 폼을 하나 만들겠습니다. 폼 안에다가 요 내용을 다 넣도록 하겠습니다.
									그리고 아이디는 일부러 폼1 하고, 액션은 투두 업데이트2 로 보내겠습니다. 맞는가 볼까요. 업데이트 컨트롤러 보면 똑같이 되어있죠. 수정은 포스트로 한다고 했ㅇ까 메소드 붙여주시고
										제목은 바꿀 수 있기에 리드온리, 뒈이트, 체크박스도 제거를 해줬습니다. 수정하기 버튼을 누르면 되는 거라서...
										필요없는 버튼은 지우고 새로 만들겠습니다
										수정하기라고 새로 하나 만들었죠
					두 포스트 작업
						앞서 수정 화면 했으니까 이제 수정하는 목적, 로직처리 바로하겠습니다. 지금 반복되는 거 탭하도록 하겠습니다 업데이트 컨트롤러에서 작업이요
						여기서 중요한 건 체크박스 처리 여부인데요. 리퀘스트 파라미터 해서 체크박스 가지고 오게 되면 체크가 되면 on으로 오게 됩니다. 피니쉬드 문자열이니까 임의로 피니쉬드 STR 해주고 이게 트루이면 문자열이면 on으로 전달을 받게 됩니다. 이거 하나 체크를 해주시고요
						이제 수정처리하겠다, 화면에서 수정 내용을 전닯다고 실제 수정 작업을 할 겁니다. 먼저는 전달 받은 데이터 확인을 해야겠죠. 어떻게 할 거냐면요. 

일단은 데이터를 변수에 다 담아서 해도 됩니다. 예를 들면 먼저 tno 번호부터 확인을 해야겠죠. 이건 받았다고 해서 겟 tno 라 명명하겠습니다. 어디서냐면 req.겟 파라미더 해서 tno로 받습니다
							자 근데 이건 계속 문자열이라고 했거든요. 화면에서 쿼리스트롱으로 넘어가는 건 다 문자열이니까 여기다가 파스 롱 해서 문자열을 담아주시고요. 이 문자열을 숫자형태로 변환하나 해주시고요. 지금 전달받은 데이터 확인을 하는 작업이랍니다
							이제 제목도 전달을 받죠. 겟 타이틀이라고 하겠습니다. 겟파라미터 타이틀이라고 해서 전달을 받을게요
							이제 데이트 타입도 받고, 로컬데이트 겟 듀데이트라고 이름 붙이고 요건 리퀘스트에 겟 파라미터에 넘어온 데이터 이름인 듀데이트 기재해볼게요. 근데 형식을 로컬데이터로 파싱을 해야합니다. 그래서 로컬데이트 파스 해서 이 문자열 되어있던 부분을 감싸서 파싱을 해주시면 되고, 지정할 때 앞서 했던 포맷터 형식으로 하겠다, 해서 작업을 해주면 문법이 완성된답니다
							그리고 피니쉬도 널이 아니고 온이라고 하면 트루를 할거니까 불리언 하고 겟 피니쉬드 하고, 
								여기는 어떻게 할 거냐면, 피니시가 널이 아니고, 트루가 아니라 온이라고 한다면, 겟피니시드에 트루를 넣겠습니다. 
								이제 전달 다 받았죠. 이걸 어디 담을 거냐면 TodoDTO에 담아서 서비스에 전달할 겁니다
								모델 클래스. TodoDTO 담아 서비스 전달
									아까 받은 정보들 담아서 빌드패턴으로 작성하시면 된답니다. 이쁘게 잘 담은 걸 이제 어떡할까요
									잘 전달을 하면 되겠죠. 그 전에 로그 인포해서 일단 어디서 투두업데이트 컨트롤러에서 두 포스트 작업 중입니다, 하나 남겨놓겠습니다
									자 이제 서비스 전달을 해볼게요. 아까 만들었던 업데이트 컨트롤러에서 작업 중입니다. 트라이 캐치에서 넌타입 하셔도 되고 다양하게 보여드리기 위해 트린트스테이크트레이스로 역추적하는 걸로 할게요. 그리고 투두 서비스에다가 모디파이 수정할 내용 담아 전달하면 끝
										수정이 잘 되면 PRG 패턴이라고 해서 리다이렉트 해야겠죠. 리스판스에다 샌드 리다이렉트 하시면 되겠죠. 근데 리스판스가 잘 못 됐네요. 풀로 다 적혀있어서 수정할게요
										아 근데 그냥 원래대로 할게요
										수정은 이동하고 나서 목록으로 가주세요 쓰고 마무리. 제가 작업을 좀 많이 했습니다. 수정과 포스트를 한번에 작업을 했으니까요.
					테스트 및 오류
						투두 업데이트 조회하면 투두 리드2에 있는 건데 수정을 할게요.. 또 수정폼 미구현도 바꿔주셨고요
						하위 주제 2
						이거 확인하는 방법은 업데이트 컨트롤러로 가시면 요렇게 되어있습니다. 투두 리드 2번에서 수정폼 부분을 바꿔보면 수정품을 눌렀을 때 정확하게 바뀌죠
						이렇게. 그럼 제목을 바꿔도 수정이 잘 될 겁니다. 오타 있던 부분까지 수정을 완료했네요.
						글쓰기 전체목록 하나조회 전체조회 수정 삭제까지 CRUD를 만들어봤습니다. 여기까지가 저희가 앞으로 작업할 샘플 1입니다.. 아, 빠진 게 있는데 셋 인코딩이 빠졌네요. 
						레그로 가서 서버단에서 처리하는 게 빠졌는데 투두 레그컨트롤러 가셔서요. 포스트처리할 때 있는 인코딩 보이죠. 이걸 업데이트에서, 포스트 처리 가셔서 
						요렇게 추가를 해주시면 된답니다
	5교시
		기본적인 CRUD를 했었으니까 부가적인 부분을 알려드릴 텐데요. 핵심적인 것은 어쨌거나 DB 연결하고 컨트롤로 모델 뷰 등 DAO 관련된 것들이고요. 이번엔 다른 걸 한번 해보겠습니다.
	6교시
		쿠키, 세션, 리스너
			개요. 기본
				메모장 19번에 기본적인 내용부터 해서 적어둘 테니까 한번 읽어보겠습니다.
				쿠키
					클라이언트에 저장되는 문자열 형태의 키배ㅠㄹ류 형태 데이터입니다. 웹브라우저와 서버의 관계를 알게되었고, 이제 JSP 관련 프로젝트에서 기본적인 화면과 해당 서버의 흐름을 알게 됐죠. 

여기서 쿠키란 건 웹 브라우저의 기록을 가져가 저장한다는 건데요. 웹브라우저 설정에 가서 보시게 되면, 개인 정보 보호 및 보안을 보면 인터넷 사용 기록이나 제 삼자 쿠키에 대한 내용이 나오죠. 

해당 개인 정보에 대한 내용 등이 쿠키형태로 저장이 되는 거랍니다. 이에 대한 내용들을 확인할 수가 있습니다. 어떤 쿠키 내용이 들어갔는지 등은 웹 브라우저에서 관리를 하는 거죠. 저희는 임시로 문자열 형태로 저장하는지 정도를 확인해보겠습니다.
						쿠키같은 경우엔 브라우저가 최초 서버 호출해 쿠키 확인하죠(없으면 전송 안 함)
						그럼 서버가 응답해서 헤더로 쿠키 전송하죠
						그럼 브라우저는 저장 방식을 유효기간별로 정하죠. 있으면 파일, 없으면 메모리
						서버는 전달받은 쿠키 활용하죠
						보통 쿠키는 제이세션 아이디같은 게 만들어지는 형태고요.. 보통 메모리에 보관이 된답니다.
						개발자가 정의한 건 이런 특성으로 좀 상이하죠
						예시는 대충 이렇습니다
					확인
						투두리스트 화면에서 개발자 도구 한번 열어볼게요. 그리고 새로고침하고 애플리케이션으로 들어가보면 여기에 쿠키스가 있어요.
							여기 제이세션 아이디가 있죠. 시스템엣 최초로 발급을 해준 거라 보시면 됩니다. 
					결론
						웹브라우저 측에서 저장되는 하나의 문자열 형태이며, 크기는 4kb 정도라는 거죠.
				세션
					개념
						서버가 임시로 저장하는 메모리죠. 웹 서버는 기본적으로 무상태(요청받고 연결하면 끝나는 구조)이지만 임시 저장이 필요하죠. 

그래서 톰캣서버나 서블릿 리퀘스트를 확장해서 세션 정보를 제공합니다.

저희는 세션을 이용해서 로그인을 체크하는 걸 한번 해볼 예정입니다.
모바일은 또 앱 특성상 세션과 비슷하게 쉐어드 프리퍼런스라고 임시 저장 메모리 등이 있답니다. 이걸 가지고 무러 할 수 있을까요?
							세션 이용해서 이런 게 가능하죠
							자 이걸 한번 작업해볼게요
			쿠키나 세션 이용한 웹 로그인 처리 구현 작업
(정상인 경우만 글쓰기 폼 화면에 접근 가능)
				투두 레그 컨트롤러에서 작업을 해볼게요
					세션 이용방법

세션이 있다면 내용 확인, 없다면 따로 생성하거나 하는 작업을 해볼 예정입니다. 어쨌거나 세션 이용 방법이죠.
					저희는 두겟에 가서, 작업을 추가하는 걸로 할 텐데요.
화면에 전달하는 게 되어있다면 그 위에다가 추가작업을 할게요
					추가작업은 어떤 거냐면요. 세션을 이용한 시스템이 제공한 세션을 확인을 먼저해보겠습니다.. 세션을 확인할 수 있는 클래스가 있죠. httpssion이 있고요 리퀘스트 해서 이용하면 이용할 수 있는 세션 객체를 활용가능하게 된답니다.
						기존에 JSESSIONID 가 없는 새로운 사용자를 확인하는 것부터인데요. 쉽게 말해 최초에 웹서버 접근한 상태라고 보시면 됩니다.
						이프문을 통해서 만약 처음 방문했다면, 제이세션 시스템 쿠키가 새로 만들어진 사용자하고 기록도 남기고, 어디로 보낼 거냐면요 응답객체 리스판스 이용해 샌드 리다이렉트 하겠습니다.

만들지 않았지만 로그인이라는 곳으로 보내기로 하고 리턴할게요.
						자 그리고 나서 제이세션 시스템 제공하는 시스템 아이디가 없는 사용자 확인을 하고요, 그 다음엔 제이세션 아이디는 있으나 해당 세션에 대한 컨텍스트(보통은 정보라고 보면 됩니다)에 로그인 인포라는 이름으로 객체가 없는 경우도 있겠죠. 이런 경우를 따져 작성해볼게요
							이프라고 작성을 하시고 로그인인포라는 이름이 만약 널, 비어있다면 로그.인포에다가 로그인 정보가 없는 사용자 출력하게 하고 샌드 리다이렉트 해서 로그인으로 보내겠습니다.
						그리고 처음 접속한 경우도 아니고 로그인 인포라는 객체가 있다면 어떨까요? 이렇게가 사실 정상적인 상태입니다.
1) JSSESIONID 존재
2) LoginINFO 가 있다는 건데요.

이럼 겟 리퀘스트 통해서 웹인포의 특정한 화면으로 이동하게 하겠습니다.
						자 저희는 참고로, 로그인은 아직 안 만들었습니다. 그리고 글쓰기 화면이 다 탭을 해서 달라져있는데 메모 10번에 가면 정해놓은 표가 있죠. 이 형식으로 수정을 해주는 작업도 간단히 해볼게요.

화면에 제시할 때 todo레지스터2로 오면 정상처리하고, 화면같은 경우는 밑에 보시면 todo 등록화면이 todoreg로 되어있거든요. 그래서 이것도 바꾸겠습니다. 
			테스트 1
				준비물1
					자 웹브라우저 todo/list2 열어보시고, 지금은 글쓰기 쪽으로 누르면 원래는 잘 간답니다. 이제 화면에서 404가 나오게 되는데요. 로그인이라는 것을 아직 안 만들었으니까요.
					이제 제이세션이라고 해서 애플리케이션 개발자 도구 들어가시고, 쿠키스 로컬호스트 8080 되어있는 쿠키고요, 이 시스템 쿠키를 삭제해보겠습니다.이게 준비물 1번입니다
				준비물 2
					그 다음 서비스에 가서 콘솔 우클릭해서 모두 삭제를 했고요. 그 뒤에 새로고침 또는 '글쓰기'를 다시 눌러보겠습니다. 
					자, 이렇게 삭제하고 글쓰기 버튼을 눌렀죠. 요렇게 뜨는데요
				확인
					이렇게 해서 확인하려는 건, 결국 제이세션 쿠키가 제대로 찍히는지를 확인해보려는 거죠.  최초로 접속한 사용자에 대해서 만드려는 거 맞니? 응 맞아, 이거인 거죠.
					그러면 이제 글쓰기, 개발자 도구, 쿠키의 제이세션 확인한 상태에서 별 반응 없는 서버에 반응이 생기게 될 겁니다. 일단 로그인 화면은 이렇고요
					그리고 서버 메시지 보면 아마 요렇게 나오게 될 겁니다. 이거 확인을 하시면, 그 다음 스텝을 밟아볼게요. 
			테스트 2
				네트워크에 잠시 가서, 로그인 없는 건 냅둬놓고 레지스터 패킷을 클릭해 열어두면 투두 레지스터 2번으로 가는 게 나와있습니다. 
				그리고 그 밑에 응답 헤더에 가보면 셋 쿠키라고 해서 최초로 했을 때 이런 게 나온답니다 
		로그인 컨트롤러 작업
			투두에서 로그인 컨트롤러 만들어볼게요
얘는 로그인 화면을 안내해주는 역할이라 보심 좋을 거 같아요. 

로긴 컨트롤러니까, 익스텐즈, HTTP 서블릿, 그 다음 웹, 웹 서블릿
			그리고 여기다가 간단하게 이름, 이름은 로긴 컨트롤러로. URL은 로그인
			그 다음에 라이브러리 쓸 거니까 @LOG4J2 하고 틀에 따라서 작업도 할게요. 반복되는 거 이제 아실 거에요.
			간단하게 로그인 인포 넣어주고, 로그인컨트롤러, 두겟 확인 중이라고 기재해둘게요.
그리고 여기서 리퀘스트 디스패쳐. 어디로 화면 제공할거냐면 웹, 인포에 바로 그냥 로그인.JSP로 바로 가고, 화면 전달해야하니까 포워드로 전달. 
				그리고 간단하게 로그인 화면도 작업해볼게요
				웹 인포에 밖에 투우에다가 임시로 하나 만들게요.
				로그인 폼을 간단하게 만들자면, 입력한 값을 인풋. 타입은 텍스트. 네임은 mid 쓰시고 비번은 mpw 이런 식으로 임의로 하겠습니다. 텍스트로.
				로그인 로직처리는 /login으로 보내고 포스트로 해서 기본 틀만 만들었어요. 이제 뼈대 정도만 만든 거고 두포스트 부분은 작업을 아직 안했답니다. 기본 화면과 로그인 컨트롤러 작업 정도 했어요
	6교시.
로그인 처리 구현 3. 
세션에 mid+mpw 더한 문자열 값으로 저장
임시 로그인 로직 구현 중
		기본적인 구현
(세션이 있으면 보여줌)
			간단히 로그인 화면 확인부터 해볼게요
			전략
			일단 리퀘스트로 파라미터라고 해서 mid 값을 가져오고, 가지고 온 문자열을 string mid 에 담을게요. 
그것과 똑같이 pw 도 mpw 받아와서 작업하고요. 
임의로 2개를 조합해볼게요. 스트링 str = mid + mpw ; 해서 세션에 저장할게요
				세션을 쓰려면 항상 http라는 객체가 필요합니다. 그래서 초기화로 키가 로긴 인포고, 값은 mimd+mpw 로 저장하고요. 자바의 세터로 생각하시면 이해가 편해요. 
				요렇게 저장하고 나서 투두의 리스트로 2번으로 보낼게요
			이렇게 하고 나서 애플리케이션 쿠키 부분에 암것도 없었죠. 시스템쿠키 빼고는. 근데 로그인을 탕, 하고 나면 세션에 대해서 확인을 할 건데요.

글쓰기란 곳에 가서 글쓰기를 눌러보겠습니다. 이제 보시면 아까전에는 로그인 화면으로 계속 갔는데, 등록 임시 화면으로 가고 있습니다. 글쓰기를 눌러 폼으로 제대로 가는지 확인을 하는 작업인 거죠. 

				세션의 정보 확인(참고로 세션은 서버 메모리 공간. 확인 방법은 2가지, 
(1)서버의 컨트롤러나 자바파일 
(2)웹상에서의 확인)

그 다음으로 로그인을 하고 나면 해당 세션 쪽에 로그인 인포라는 게 저장이 됩니다. 여긴 임시 메모리 공간이기에 확인을 할 수도 있습니다. 어디로 가서 확인할 거냐면, 투두 리스트에 잠시 가서, 방금 만들었던 세션을 확인해볼게요."
	6교시.
확인용 세션 도구 임시.
웹화면의 목록 화면에서 확인 2 
		로그인이 됐을 때
			
				세션 스코프의 로긴 인포라는 게 비어있지 않다면, 출력을 이렇게 하게 하겠습니다.
				또 비어있는 경우도 있겠죠. C에다가 이프 테스트라고 하고, 달러 중괄호 열고 이번엔 엠프티, 뭐가 비냐면 세션스포크의 로긴인포라는 게 비어있다면, 여기는 P에다가 로그인의 상태가 되지 않음.
		자동화
			기본 개념
				필터
					기본
						이런 로그인 처리 과정을 매번하는 것보다 자동으로 필터링하게 하면 좋겠죠. 19번 메모 보면 필터가 나오는데 모든 요청이 꼭 거쳐가는 컴포넌트입니다.
						이 필터란 기능을 이용해 로그인에 요구되는 기능을 체크한번 해보겠습니다.
					작업
						1. 패키지, 클래스 생성.

필터라는 패키지와 체크 패키지를 하나 만들어줬습니다. 일단.
						2. 규칙 작성
							준비
								조금 얘는 작성이 다른데 임플먼트 필터라는 걸 구현해야하는데요.

필터는 자바x에 있는 서블릿의 기능을 가져와야 합니다. 이런 인터페이스를 구현할 때 반드시 재정의해야하는데요. 

저희는 두 필터라고 해서 동작하는 거부터 한번 확인하겠습니다. 필터구현하게 되면 반드시 오버라이드를 의무적으로 구현해주세요, 라고 되어있기에 이렇게 하는 거죠.
								이너테이션엔 규칙을 지정해볼게요. 웹필터에다가 url 패턴은 웹브라우저에서 해당 /todo/* 시작하는 모든 것들에 대해서 검사를 다 하겠다는 걸 먼저 기재해볼게요.
								그 다음 임시로 위치를 알려줘야 하니까 Log4j2 하고 로그.인포 해서 하는 위치 기재해주고요. 
								그리고 필터체인을 이용해서 구현할 예정입니다.
이렇게 위치만 간단히 지정을 했고요. 이제 이걸 가지고 어떻게 한다고요.
									
									참고로 필터체인은 이런 의미라 보시면 됩니다.
									실제로 해야할 건 로그인 체크 규칙이죠.
							작업
(세션을 활용한 로그인 체크)
								로그인체크

실질적으로 로그인 체크.를 하겠다는 거죠.
계획을 한번 짜볼게요.
								서버에서 서블릿을 실제로 쓰는 게 아니라 상위버전이라고 보면 되는데 이걸 다운캐스팅해서 쓰겠습니다. 

서블릿리퀘스트를 http서블릿리퀘스트로 다운캐스팅해서 쓰겠다. 왜냐면 실질적으로는 http 의 기능을 쓸 거기 때문이죠.
									서블릿 리퀘스트를 http 서블릿으로 형변환을 할게요. 이름이 불편하지만 걍 쓸게요.
									서블릿 리스판스라는 걸 형변환할게요. 다운 캐스팅했으니까 받을 때도 리스판스로 받고.

이런 구조를 아무 컨트롤로 보면. 
										이런 식으로 구조를 볼 수가 있죠.
만약에 이런 구조가 궁금하신 분들은 
										이런 식으로 서블릿 리퀘스트, 그리고 거기서 또 클릭클릭 타고 들어가보면 볼 수가 있다면. 참고만 해주시길 바랍니다.
									이런 부모타입을 이용하기보다는 자식타입 기능을 이용할 거라서 이렇게 형변환을 하는 거죠. 자 이제 세션 이용하는 도구도 가져올게요
									그리고 검사를 뭐 할 거냐면 이걸 검사할 겁니다. 세션에 키의 이름으로 이렇게 썼거든요. 로긴 인포. 여기에 값으로 아이디와 패스를 합쳐놨죠. 이게 존재하면 로긴 된 상태이며 안 존재하면(세션에 키가 없다면) 로그인이 안 된 거라 판단하겠습니다.
										세션에 겟 어트리뷰트 해서 로긴 값이 있다! null이다 하면 (로긴 정보가 없다) 바로 로그인으로 보내버릴게요. 
										만약에 있다고 하면 계속 진행을 하겠다면, 계속 진행하겠다고 보면 되는 거겠죠. 지금은 기능구현의 4번. 웹 필터란 도구를 이용해 서버에 접근시에 지정한 경로에, 세션의 정보가 없다면 로그인이 안 되었다고 간주하기라는 거죠.
						3. 확인 위한 작업
(투두 리스트로 왔을 때 필터에 걸리냐의 확인)
*서비스의 콘솔로 지워가면서 확인하고 있음.
							안 되었다고 간주한 시나리오
(검사 대상의 확인부터)
								투두로 올 때마다 확인하겠다고 했었죠. 투두리스트에서 엔터 쳤더니 로그인 화면으로 가게 되는 거죠.(콘솔 지우고, 웹브라우저에서 todo/list2 > 로그인 화면) 왜냐면 로긴 인포가 없기 때문이죠.
									확인을 해보면 요렇게 뜨는데요
									뭔 소리냐면 투두로 왔기 때문에 필터에서 작업중, 이라고 걸리게 된다는 거죠. 이 URL로 접근 시에는 검사대상이 된다라는 거죠. 아까 필터 작성을 했었죠.
									또 작업 중이긴 한데 세션의 키값이 없으면, 뭐라고 출력되게 하면 좋겠죠. 작업 중이고 로그인 인포가 비어있습니다. 이렇게 하면 좋겠죠.
									또 해보겠습니다. 리스트2에서 땅, 하니 로그인 화면으로 보게 되는데 콘솔을 보게 되면, 어디에 작업 중이며 어디로 오게 되면 접근시 검사 대상이며 비어있다고 뜨죠. 
								검사대상자
									투두라고 되어있지 않은 경우에는 콘솔에 검사대상자 어쩌고가 안 뜨죠. 이건 todo가 아닌 곳으로 접근했기 때문인 거죠.
									또 로긴 컨트롤러를 한번 볼게요
									로긴 컨트롤러 가서 두포스트 처리하는 것 중에 요렇게 값을 지정하는 게 제일 중요합니다. 셋터!
										하위 주제 1
										확인되죠
										요거 잘 보셔야 합니다.
두포스트로 로긴 컨트롤러에서 처리를 했었어요. 그리고 두 겟으로 가게 된 거죠
						필터는 로긴 체크도 하지만, 한글 체크도 한다든지 하는 기능이 있답니다. 로그아웃도 이제 같이 해봅시다. 
	7교시
(매우 중요)
		중요한 필터에 대해서!!!!
(작동방식을 꼭 이해하고 알아야 함. 이것도 제대로 숙지, 이해, 외우면 좋음)
			일단 지금 작업하고 있는 것들은 위치를 간단히 알려드리고 남은 작업 알려드릴게요.
				필터에 로긴 체크 필터 들어오세요
				이걸 파악을 해야 뒤의 것을 잘 정의하고 배울 수 있답니다.
				로긴 체크 필터 
쉽게 말해 뭔가 검사. 
뭘 검사?
					웹 브라우저 요청때마다 거름망이 규칙으로 무조건 지나가게 됩니다. 목록이든 글쓰기든, 포스트 처리든 뭐든 간에 말이죠. 필터를 꼭 지나쳐가야하죠. (모든 요청)
					근데 작업을 하면서 모든 부분이 아니라 특정으로 지정을 했었죠. 한번은 투두, 인덱스. 

확인은 콘솔창에서 했었죠
						콘솔
							투두 리스트.
통과.
규칙에 합당해서
								로긴 인포가 널이면 확인하고 아니면 위 검사 규칙이 끝나고 이어서 진행하겠다. 요기서 통과했기에. 만약 못했었으면 로긴으로 갔었음.
							아닌 경우도 있었죠. 인덱스 이건 직접 확인해보시길
		로그아웃 작업
(세션의 로긴인포값 삭제로 로그아웃 기능 구현)
			로그아웃 컨트롤러 작업
(로그인 이후 개념 이후를 돕기 위해 작업 로그아웃으로 전개하기로 결정)
				작업
					준비
						웹 상속 받고 네임 서블릿, 소문자로 이름 지정하고, URL 패턴도 로그아웃 하고, 콘솔에 로그 찍어봐야하니까 lOG4J2 도 해줬습니다.
						정의하겠습니다. 화면이 아니라 로직 처리하는 곳이라서 두포스트라고 해서 만들겠습니다.  초기셋팅이라고 봐도 되겠죠. 이것도 계속 반복되는 패턴이었으니까 가볍게 봐주세요.
						그리고 마찬가지로 여기도 뭐하는 작업인지 표기해줘야겠죠. 로그아웃 컨트롤러, 두포스트 작업 중 남겨주시고요. 로그아웃 처리하는 작업도 해볼 텐데요.
					실질 로직 작업
						참고.

세션 로긴정보만 제거하면, 자연스럽게 로그아웃 되는데요.
현재 임시 로그인 로직입니다. 실무로직은 아니니까 오해마시고, '세션을 이용한 로그인 체크의 연습'이랍니다.
							HTTP 세션, 작업하고 세션 제거하러 가보겠습니다. 로그아웃이니까요. 세션의 인밸리데이트(리플래쉬라고 보시면 됩니다) 이후 리스판스 샌드리다이렉트해서 어디로 보낼 거냐면, 인덱스로 보내도 되고 로긴 화면으로 보내도 됩니다. 일단 인덱스 폼으로 보내도록 할게요.
						1.리스트 화면, todolist.jsp에 잠시 가볼게요
여기 보면 이런 저런 구성이 있는데요. 
							화면 구성
								로그아웃 표기를 이제 하고 싶죠. 로긴 됐으면 정보 보여주는 말고, 로그아웃 버튼도 한번 넣어보도록 하죠.

액션은 로그아웃, 메서드 포스트, 버튼은 간단하게 로그아웃. 요렇게 구성을 했고요.
								보시는 것처럼 구현이 됐는데요
									정상 로그아웃이 됐죠. 
									그리고 로그아웃 했다는 것을 콘솔에서 볼 수도 있답니다. 당연하게도 todo/list2에 들어가거나 해도 당연히 못 들어갑니다. 왜냐면 필터에 다 막혀서 그렇습니다. 필터에 막혀서 세션의 로그인 정보가 없다면 싹다 리다이렉트 화면으로 가게 됩니다. 이게 필터의 기능인 거죠.
										정상 로그인 됐을 때
										똑같이 reg2로 가도 임시로그인 화면으로 옮겨짐
					필터의 또 다른 장점
(한글이 좋아!)
(필터를 활용한 웹 브라우저 모든 요청에 대해서 UTF 8 설정 적용 예시)
						이제까지 매번 한글을 처리할 때, 웹클라에서 한글로 요청하면 필터가 검사해서 매번 UTF를 적용하는 조건을 걸 수도 있습니다.

원래는 이렇게 모든 코드에 이런 설정을 걸고 있었죠. 필터가 검사해서 이걸 미리 설정하면 상당히 편해지겠죠?
						필터 한글 적용 작업
							UTF 8 필터를 한번 만들어봅시다. 전체로 하나 설정하는 게 훨씬 편하니까요. 어제 설명을 드렸었던 임시방편 한줄짜리가 아니라, 전체를 하는 편한방법이 있다고 했던 게 바로 이 방법이랍니다.

UTF 8 클래스를 한번 만들고, 구현을 해볼게요
								필터는 참고로 자바x의 서블릿을 임플리먼츠 해줘야합니다. 그리고 오버라이딩. 재정의를 해주셔야 하는데요. 두 필터 해서 지정을 해주겠습니다.
								그리고 웹 필터를 해줄 건데 url패턴을 보면 투두 이런 식으로 적는 게 아니라 모든 사이트에 들어오게 되면, 전체에 일괄적으로 맞춰주겠다는 걸 적어줄게요.

모든 경로에 대해서 검사 대상자로 일단 하겠다는 내용부터 먼저 설정을 해봅시다.
								또 확인을 해야하니까 LOg4j2 써주시고, 로그인포 해주시고 작업 뭐하고 있는지도 써주시면 되겠죠. UT8 필터 작업 중이고요, 검사 대상은 모든 경로 /* 요렇게 표현합니다
								요것도 마찬가지 서빌릿 리퀘스트는 부모 타입이기 때문에, 자식타입으로 다운 캐스팅하겠ㅅ브니다. 그리고 이걸 받을 때도 http 서블릿리퀘스트의 req. 실제 작업은 이 req에서 하는 거죠. 뭐 할거냐면 UTf -8하는 거죠.

ㄱ리고 체인에 필터. 이러한 규칙 검사 후, 다시 계속 진행. 이로써 모든 요청에 대해서 UTF-8을 적용하는 게 적용이 됐답니다.
									참고. 이제 기존에 있던 한줄 UTF 코드는 주석처리를 해도 다 되겠죠? 
						필터 확인 작업
							레그 컨트롤러에 보면 주석처리를 해놨습니다.
글쓰기 화면으로 가기 위해 로그인을 하고 이동해서 글쓰기 해보겠습니다. 테스트 작업으로 한글 등록해볼게요. 
							다음엔 일부러 깨지게 해볼게요. 몯느 경로로 된 걸 주석처리하거나 설정 꺼버리겠습니다.
								확인을 해보면 이제 한글 등록을 해보면, 글자가 깨지는 걸 볼 수가 있습니다.

---

**Cursor**

안녕하세요! 어제 배운 내용을 정리해주셨네요. 정말 체계적으로 잘 정리하셨습니다. 

현재 프로젝트 구조를 보니 Spring 기반의 Todo 애플리케이션을 개발하고 계시는 것 같습니다. 어제 배운 핵심 내용들을 보면:

## 주요 학습 내용

### 1. MVC 패턴과 전달 구조
- 컨트롤러가 서비스에 요청 → 서비스가 DAO에 요청 → DB 처리 후 역순으로 전달
- "서비스야, 나 전달할 거 있으니까 너도 나한테 전달해줄래?" 패턴

### 2. 병렬처리와 스트림
- 기존 반복문 대신 스트림의 `map()` 사용
- VO → DTO 변환을 병렬처리로 효율화
- `collect(Collectors.toList())`로 리스트화

### 3. CRUD 작업 흐름
- **등록**: GET(화면) → POST(처리) → 리다이렉트(PRG 패턴)
- **조회**: 쿼리스트링으로 tno 받아서 서비스 호출
- **수정**: GET(수정폼) → POST(수정처리) → 리다이렉트
- **삭제**: POST로 tno 받아서 삭제 후 리다이렉트

### 4. 세션과 쿠키
- JSESSIONID: 시스템이 자동 생성하는 세션 쿠키
- 세션: 서버 메모리에 임시 저장
- 로그인 체크: 세션에 loginInfo 존재 여부 확인

### 5. 필터(Filter)
- 모든 요청이 거쳐가는 컴포넌트
- 로그인 체크 필터: `/todo/*` 경로 검사
- UTF-8 필터: 모든 경로에 인코딩 설정

현재 `calcu.java` 파일을 보고 계시는데, 이 파일은 간단한 조건문 예제로 보입니다. 

혹시 특정 부분에 대해 더 자세히 알고 싶으시거나, 코드 구현에 도움이 필요하시면 말씀해 주세요!

---

**User**

지금 내가 주석을 단 방식을 보면 코딩 구문을 출력하거나 활용하는 식으로 되어있잖아. 이런 방식의 코딩을 뭐라고 해?

---

**Cursor**

현재 보시는 코드에서 주석을 단 방식을 보면, **"요구사항 주석"** 또는 **"문제 정의 주석"**이라고 합니다.

구체적으로는:

## 주석의 종류

1. **요구사항 주석 (Requirement Comments)**
   - "정적인 메인 메서드를 만들고 age가 18 이상이고 hasID가 참인지 확인해 출력해."
   - "사용자가 티켓이 없다면 경고메시지를 출력한다."
   - "hastTicket 이 true일 때만 입장시킨다."

2. **메서드 설명 주석 (Method Documentation Comments)**
   - "변수 a를 참조형으로 하는 메서드 dool은 변수 a의 값을 2배로 만들어 출력하는 메서드이다."

## 이런 주석 방식의 특징

- **문제 정의 중심**: "~를 해라", "~를 만들어라" 형태
- **기능 명세**: 어떤 기능을 구현해야 하는지 명확히 제시
- **학습용 코딩**: 프로그래밍 학습 과정에서 자주 사용되는 방식

## 현재 코드의 문제점

하지만 현재 코드에는 **중복된 main 메서드**가 있어서 컴파일 오류가 발생합니다. Java에서는 하나의 클래스에 하나의 main 메서드만 가질 수 있습니다.

이런 주석 방식은 특히 **프로그래밍 교육**이나 **코딩 테스트**에서 자주 사용되는 패턴입니다. 요구사항을 주석으로 제시하고, 그에 맞는 코드를 구현하도록 하는 방식이죠.

---

**User**

그럼 요구사항 주석, 메서드 설명 주석을 통합한 방식을 뭐라고 해? 없다면 괜찮은 걸로 하나 명명해줘 추천해줘.

---

**Cursor**

요구사항 주석과 메서드 설명 주석을 통합한 방식을 **"통합 명세 주석 (Integrated Specification Comments)"** 또는 **"기능 명세 주석 (Feature Specification Comments)"**이라고 할 수 있습니다.

## 추천 명명

가장 적절한 명칭은 **"통합 명세 주석 (Integrated Specification Comments)"**입니다.

## 이 방식의 특징

1. **요구사항 + 구현 설명 통합**
   - "정적인 메인 메서드를 만들고 age가 18 이상이고 hasID가 참인지 확인해 출력해."
   - "변수 a를 참조형으로 하는 메서드 dool은 변수 a의 값을 2배로 만들어 출력하는 메서드이다."

2. **학습 및 교육 목적에 최적화**
   - 문제 정의와 해결 방법을 동시에 제시
   - 코드의 목적과 동작을 명확히 설명

3. **개발 과정에서의 활용**
   - 요구사항 분석 → 설계 → 구현의 전체 과정을 주석으로 표현
   - 코드 리뷰나 문서화에 유용

## 다른 대안 명칭들

- **"통합 기능 주석 (Integrated Feature Comments)"**
- **"요구사항-구현 통합 주석 (Requirement-Implementation Integrated Comments)"**
- **"기능 명세 통합 주석 (Feature Specification Integrated Comments)"**

이런 방식은 특히 **교육용 코딩**, **프로토타이핑**, **기능 명세서 작성**에서 매우 유용한 패턴입니다.

---

**User**

Feature Specification Integrated Comments 요거 마음에 든다. 기능 명세 통합 주석. 

---

**Cursor**

좋은 선택이네요! **"Feature Specification Integrated Comments (기능 명세 통합 주석)"**이 정말 적절한 명칭입니다.

## 이 명칭의 장점

1. **명확성**: "Feature"가 기능을, "Specification"이 명세를, "Integrated"가 통합을 명확히 표현
2. **전문성**: 개발 용어로 잘 정리되어 있어서 기술 문서에서도 사용하기 적합
3. **국제적**: 영어 명칭이 있어서 해외 개발자들과도 소통 가능

## 실제 활용 예시

```java
// Feature Specification Integrated Comments 예시
// 사용자 인증 기능: 사용자가 티켓이 없다면 경고메시지를 출력한다.
public static void checkTicket(boolean hasTicket) {
    if (!hasTicket) {
        System.out.println("티켓이 없습니다.");
    }
}

// 데이터 변환 기능: 변수 a를 참조형으로 하는 메서드 dool은 변수 a의 값을 2배로 만들어 출력하는 메서드이다.
public static void dool(int a) {
    a = a * 2;
    System.out.println(a);
}
```

이제 이 용어를 사용해서 코드 작성 시 주석 스타일을 일관성 있게 유지할 수 있겠네요! 앞으로 프로젝트에서 이 방식을 활용하시면 코드의 가독성과 유지보수성이 크게 향상될 것입니다.

```java
// Feature Specification Integrated Comments 예시
// 사용자 인증 기능: 사용자가 티켓이 없다면 경고메시지를 출력한다.
public static void checkTicket(boolean hasTicket) {
    if (!hasTicket) {
        System.out.println("티켓이 없습니다.");
    }
}

// 데이터 변환 기능: 변수 a를 참조형으로 하는 메서드 dool은 변수 a의 값을 2배로 만들어 출력하는 메서드이다.
public static void dool(int a) {
    a = a * 2;
    System.out.println(a);
}
```

---

**User**

그럼 기능 명세 통합 주석으로 여기의 주석을 바꿔서 작업해줘

---

**Cursor**

```java
package com.busanit501.hello_project._2todo.controller;

import com.busanit501.hello_project._2todo.dto.TodoDTO;
import com.busanit501.hello_project._2todo.service.TodoService;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

@WebServlet(name = "todoListController" , urlPatterns = "/todo/list")
public class TodoListController extends HttpServlet {
    // Todo 목록 조회 기능: GET 요청을 받아서 TodoService에서 전체 목록을 가져와 화면에 전달하는 컨트롤러
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("todoListController.doGet 호출, 목록 화면제공. ");

        // 데이터 조회 기능: TodoService의 getList() 메서드를 호출하여 전체 Todo 목록을 DTO 리스트 형태로 반환받는다
        List< TodoDTO> dtoList = TodoService.INSTANCE.getList();

        // 화면 데이터 전달 기능: 조회된 Todo 목록을 "list"라는 키로 request 객체에 저장하여 JSP 화면에서 접근할 수 있도록 한다
        req.setAttribute("list", dtoList);

        // 화면 전달 기능: RequestDispatcher를 사용하여 /WEB-INF/todo/todoList.jsp로 포워딩하여 실제 화면을 렌더링한다
        req.getRequestDispatcher("/WEB-INF/todo/todoList.jsp").forward(req, resp);
    }

}
```

완료했습니다! 기존의 간단한 주석들을 **기능 명세 통합 주석(Feature Specification Integrated Comments)** 방식으로 변경했습니다.

## 변경된 주석의 특징

1. **요구사항 + 구현 설명 통합**: 각 기능이 무엇을 하는지와 어떻게 구현되는지를 함께 설명
2. **명확한 기능 정의**: "데이터 조회 기능", "화면 데이터 전달 기능", "화면 전달 기능" 등으로 구체적 명명
3. **기술적 세부사항 포함**: RequestDispatcher, 포워딩, 키-값 저장 등 구현 방법도 함께 설명

이제 코드를 읽는 사람이 각 부분의 목적과 동작 방식을 한 번에 이해할 수 있게 되었습니다!

---

**User**

여기도

---

**Cursor**

```java
package com.busanit501.hello_project._2todo.controller;

import com.busanit501.hello_project._2todo.dto.TodoDTO;
import com.busanit501.hello_project._2todo.service.TodoService;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = "todoReadController", urlPatterns = "/todo/read")
public class TodoReadController extends HttpServlet {
    // Todo 상세 조회 기능: GET 요청을 받아서 쿼리스트링의 tno 파라미터로 특정 Todo를 조회하여 상세 화면에 전달하는 컨트롤러

@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    System.out.println("TodoReadController : 하나 조회 ");
    
    // 파라미터 추출 기능: 쿼리스트링 형식(/todo/read?tno=100)으로 전달된 tno 값을 문자열로 받아와서 Long 타입으로 변환한다
    Long tno = Long.parseLong(req.getParameter("tno"));
    
    // 데이터 조회 기능: TodoService의 getTodoByTno() 메서드를 호출하여 특정 tno에 해당하는 Todo 정보를 DTO 형태로 반환받는다
    TodoDTO dto  = TodoService.INSTANCE.getTodoByTno(tno);
    
    // 화면 데이터 전달 기능: 조회된 Todo 정보를 "dto"라는 키로 request 객체에 저장하여 JSP 화면에서 접근할 수 있도록 한다
    req.setAttribute("dto",dto);
    
    // 화면 전달 기능: RequestDispatcher를 사용하여 /WEB-INF/todo/todoRead.jsp로 포워딩하여 상세 조회 화면을 렌더링한다
    req.getRequestDispatcher("/WEB-INF/todo/todoRead.jsp").forward(req,resp);

}
}
```

완료했습니다! `TodoReadController`도 **기능 명세 통합 주석(Feature Specification Integrated Comments)** 방식으로 변경했습니다.

## 변경된 주석의 특징

1. **클래스 레벨 주석**: Todo 상세 조회 기능의 전체적인 목적과 동작 방식을 명확히 설명
2. **단계별 기능 명세**: 
   - **파라미터 추출 기능**: 쿼리스트링 처리와 타입 변환
   - **데이터 조회 기능**: 서비스 호출과 데이터 반환
   - **화면 데이터 전달 기능**: request 객체에 데이터 저장
   - **화면 전달 기능**: JSP로 포워딩

3. **구체적인 구현 세부사항**: URL 형식, 메서드명, 키-값 쌍 등 실제 구현 방법도 함께 설명

이제 코드의 각 단계가 무엇을 하는지, 어떻게 구현되는지가 명확하게 이해됩니다!

---

**User**

여기도 

---

**Cursor**

```java
package com.busanit501.hello_project._2todo.controller;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = "todoRegController" , urlPatterns = "/todo/register")
public class TodoRegController extends HttpServlet {
    // Todo 등록 화면 제공 기능: GET 요청을 받아서 Todo 등록 폼 화면을 제공하는 컨트롤러
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("TodoRegController.doGet 호출, 입력 화면제공. ");
        
        // 화면 전달 기능: RequestDispatcher를 사용하여 /WEB-INF/todo/todoReg.jsp로 포워딩하여 등록 폼 화면을 렌더링한다
        req.getRequestDispatcher("/WEB-INF/todo/todoReg.jsp").forward(req, resp);
    }
    
    // Todo 등록 처리 기능: POST 요청을 받아서 등록 로직을 처리하고 목록 화면으로 리다이렉트하는 컨트롤러
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("TodoRegController.doPost 호출, 로직 처리 ");

        // 화면 전환 기능: PRG 패턴을 적용하여 등록 처리 후 /todo/list로 리다이렉트하여 목록 화면으로 이동한다
        resp.sendRedirect("/todo/list");
    }
    
}
```

완료했습니다! `TodoRegController`도 **기능 명세 통합 주석(Feature Specification Integrated Comments)** 방식으로 변경했습니다.

## 변경된 주석의 특징

1. **메서드별 명확한 기능 정의**:
   - **doGet**: Todo 등록 화면 제공 기능
   - **doPost**: Todo 등록 처리 기능

2. **구현 세부사항 포함**:
   - **화면 전달 기능**: RequestDispatcher와 포워딩 방식 설명
   - **화면 전환 기능**: PRG 패턴과 리다이렉트 방식 설명

3. **디자인 패턴 명시**: PRG(Post-Redirect-Get) 패턴을 명확히 언급하여 웹 개발의 모범 사례를 반영

4. **불필요한 주석 제거**: "아직 화면은 미구현" 같은 임시 주석은 제거하고 핵심 기능 설명에 집중

이제 각 메서드의 목적과 동작 방식이 명확하게 이해되며, 웹 개발의 표준 패턴도 함께 학습할 수 있습니다!

---

**User**

요것도 다시 해줘, 잘하고 있었는데 기존의 주석은 **표시를 하거나 아니면 이전 주석이구나, 알아볼 수 있게 가독성 좋은 방식해서 그대로 남겨두면 좋겠어. (befote를 뜻하는 기호가 있다면 써도 괜찮고) 

---

**Cursor**

```java
package com.busanit501.hello_project._2todo.controller;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = "todoRegController" , urlPatterns = "/todo/register")
public class TodoRegController extends HttpServlet {
    // **BEFORE**: 등록 화면 제공.
    // Todo 등록 화면 제공 기능: GET 요청을 받아서 Todo 등록 폼 화면을 제공하는 컨트롤러
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("TodoRegController.doGet 호출, 입력 화면제공. ");
        
        // **BEFORE**: 빌드 패턴으로 해당 객체에서, 사용하는 메서드를 연속적으로 사용하는 디자인 패턴형식
        // 화면 전달 기능: RequestDispatcher를 사용하여 /WEB-INF/todo/todoReg.jsp로 포워딩하여 등록 폼 화면을 렌더링한다
        req.getRequestDispatcher("/WEB-INF/todo/todoReg.jsp").forward(req, resp);
        // **BEFORE**: 아직 화면은 미구현.
    }
    
    // **BEFORE**: 등록 로직 처리,
    // Todo 등록 처리 기능: POST 요청을 받아서 등록 로직을 처리하고 목록 화면으로 리다이렉트하는 컨트롤러
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("TodoRegController.doPost 호출, 로직 처리 ");

        // **BEFORE**: 단순 화면 전환, 리다이렉트
        // 화면 전환 기능: PRG 패턴을 적용하여 등록 처리 후 /todo/list로 리다이렉트하여 목록 화면으로 이동한다
        resp.sendRedirect("/todo/list");
    }
    
}
```

완료했습니다! 이제 기존 주석들을 **`**BEFORE**`** 표시로 남겨두고, 새로운 기능 명세 통합 주석을 추가했습니다.

## 변경된 주석의 특징

1. **기존 주석 보존**: `**BEFORE**:` 표시로 원래 주석을 그대로 유지
2. **새로운 주석 추가**: 기능 명세 통합 주석으로 상세한 설명 제공
3. **비교 가능**: 변경 전후를 쉽게 비교할 수 있어 학습 효과 증대
4. **가독성 향상**: 기존 주석과 새로운 주석이 명확히 구분됨

이제 코드를 읽는 사람이:
- 원래 주석이 어떻게 작성되었는지 확인 가능
- 새로운 주석이 어떻게 개선되었는지 비교 가능
- 기능 명세 통합 주석의 장점을 직접 체험 가능

이런 방식으로 다른 파일들도 변경하시겠어요?

---

**User**

요기 꺼 이미 내가 새 방식으로 바꾸긴 했는데 혹시 이전버전 주석 기억하면 다시 달아서 해줘

---

**Cursor**

네, 이전 버전 주석을 기억해서 **BEFORE** 표시로 추가해드리겠습니다!


```java
package com.busanit501.hello_project._2todo.controller;

import com.busanit501.hello_project._2todo.dto.TodoDTO;
import com.busanit501.hello_project._2todo.service.TodoService;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = "todoReadController", urlPatterns = "/todo/read")
public class TodoReadController extends HttpServlet {
    // **BEFORE**: 화면 제공 목적, + 데이터를 담은 결과 화면.
    // Todo 상세 조회 기능: GET 요청을 받아서 쿼리스트링의 tno 파라미터로 특정 Todo를 조회하여 상세 화면에 전달하는 컨트롤러

@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    System.out.println("TodoReadController : 하나 조회 ");
    
    // **BEFORE**: 임의의  todo 번호, 100
    // **BEFORE**: 더미 데이터 가져오기, 현재는 메모리 작업,
    // **BEFORE**: /todo/read?tno=100, 쿼리 스트링 형식으로 , 파라미터 전달 받기.
    // **BEFORE**: 문자열을 받아와서, 타입 변환, 롱 타입으로
    // 파라미터 추출 기능: 쿼리스트링 형식(/todo/read?tno=100)으로 전달된 tno 값을 문자열로 받아와서 Long 타입으로 변환한다
    Long tno = Long.parseLong(req.getParameter("tno"));
    
    // **BEFORE**: TodoService 를 이용해서, 하나 조회하는 기능을 이용함.
    // 데이터 조회 기능: TodoService의 getTodoByTno() 메서드를 호출하여 특정 tno에 해당하는 Todo 정보를 DTO 형태로 반환받는다
    TodoDTO dto  = TodoService.INSTANCE.getTodoByTno(tno);
    
    // **BEFORE**: 화면에 데이터 탑재하기.
    // 화면 데이터 전달 기능: 조회된 Todo 정보를 "dto"라는 키로 request 객체에 저장하여 JSP 화면에서 접근할 수 있도록 한다
    req.setAttribute("dto",dto);
    
    // 화면 전달 기능: RequestDispatcher를 사용하여 /WEB-INF/todo/todoRead.jsp로 포워딩하여 상세 조회 화면을 렌더링한다
    req.getRequestDispatcher("/WEB-INF/todo/todoRead.jsp").forward(req,resp);

}
}
```

완료했습니다! 이제 `TodoReadController`도 기존 주석들을 **`**BEFORE**`** 표시로 추가했습니다.

## 추가된 기존 주석들

1. **클래스 레벨**: "화면 제공 목적, + 데이터를 담은 결과 화면."
2. **파라미터 처리**: 
   - "임의의 todo 번호, 100"
   - "더미 데이터 가져오기, 현재는 메모리 작업"
   - "/todo/read?tno=100, 쿼리 스트링 형식으로, 파라미터 전달 받기"
   - "문자열을 받아와서, 타입 변환, 롱 타입으로"
3. **서비스 호출**: "TodoService 를 이용해서, 하나 조회하는 기능을 이용함"
4. **데이터 전달**: "화면에 데이터 탑재하기"

이제 변경 전후를 명확히 비교할 수 있어서, 기존 주석의 간단함과 새로운 기능 명세 통합 주석의 상세함을 모두 확인할 수 있습니다!

---

**User**

여기도 해줘

---

**Cursor**

네, 기존 주석에 **BEFORE** 표시를 추가하고, 기능 명세 통합 주석(Feature Specification Integrated Comments) 방식으로 새 주석을 추가하겠습니다.  
가독성과 비교가 쉽도록 반자동 생성 관련 주석 부분에 집중해서 적용하겠습니다.

```java
package com.busanit501.hello_project._2todo.dto;

import java.time.LocalDate;

public class TodoDTO {
    private Long tno;
    private String title;
    private LocalDate dueDate;
    private boolean finished;

    // **BEFORE**: 반자동으로 생성.
    // **BEFORE**: 1) 멤법 선택 후, 반자동 생성. 먼저 이것 부터. 작업.
    // **BEFORE**: 2) lombok 라이브러리, 메모리에 자동생성
    // TodoDTO의 Getter/Setter, 생성자, toString 등은 IDE의 자동 생성 기능 또는 Lombok 라이브러리를 통해 반복 코드를 효율적으로 관리할 수 있도록 구현함

    public Long getTno() {
        return tno;
    }

    public void setTno(Long tno) {
        this.tno = tno;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public LocalDate getDueDate() {
        return dueDate;
    }

    public void setDueDate(LocalDate dueDate) {
        this.dueDate = dueDate;
    }

    public boolean isFinished() {
        return finished;
    }

    public void setFinished(boolean finished) {
        this.finished = finished;
    }

    @Override
    public String toString() {
        return "TodoDTO{" +
                "tno=" + tno +
                ", title='" + title + '\'' +
                ", dueDate=" + dueDate +
                ", finished=" + finished +
                '}';
    }

    // TodoDTO 객체의 모든 필드를 초기화하는 생성자
    public TodoDTO(Long tno, String title, LocalDate dueDate, boolean finished) {
        this.tno = tno;
        this.title = title;
        this.dueDate = dueDate;
        this.finished = finished;
    }

    // TodoDTO 객체의 기본 생성자
    public TodoDTO() {}
}

```

완료했습니다!

- 기존 주석에는 **BEFORE** 표시를 추가하여 원래의 설명을 보존했습니다.
- 기능 명세 통합 주석(Feature Specification Integrated Comments) 방식으로, 자동 생성 코드의 목적과 활용(IDE 자동 생성, Lombok 등)도 명확히 설명했습니다.
- 생성자 부분에도 각각의 역할을 명확히 주석으로 남겼습니다.

이제 변경 전후를 쉽게 비교하면서, 코드의 목적과 구조를 한눈에 파악할 수 있습니다!  
다른 파일도 같은 방식으로 원하시면 말씀해 주세요.

---

**User**

이제 앞으로 코드 작성에서 '왜' 그렇게 했는지(예를 들어 불편의 관점이라든가 효율의 관점이라든가 가독성이라든가 작동여부의 관점이라든가 하는 다양한 구문 작성의 이유들이나 동기나 문제해결의 목적 등이 있을 텐데 그걸 우선순위에 따라서 1개 또는 2개 이상 기재해서) 주석을 추출해줘. 그리고 해당 데이터 타입이 변경가능한 건지 아닌지, 변경 가능하다면 왜 변경가능한 건지(예를 들어 변수명은 임의로 설정 가능함), 그리고 다른 식으로도 구현 가능한건지(가능하다면 왜 가능한 건지), 그리고 해당 데이터 타입의 위상(클래스인지 메서드인지, 변수인지, 키워드인지, 함수인지, 함수라면 내장함수인지 등)을 구문 작성에서 '필요'에 따라서 명시해줘. 아니면 이 타입 위상은 그냥 주석과 별도로 기재해줘도 되겠다.(대신 구문 작성에서 필요했다면, 포함해서 서술할 것)

---

**Cursor**

네, 앞으로 코드 작성 시 아래와 같은 기준에 따라 주석과 타입 위상을 정리해서 제공하겠습니다.

---

## 1. **구문 작성의 이유/동기/문제해결 목적**
- **왜** 이 구문을 작성했는지, 어떤 불편함을 해소하거나, 효율·가독성·작동여부 등 어떤 관점에서 선택했는지 우선순위에 따라 1개 이상 명시

## 2. **데이터 타입의 변경 가능성**
- 변경 가능한지 여부(예: 변수명, 값, 구조 등)
- 변경 가능하다면 **왜** 가능한지(예: 변수명은 임의로 설정 가능, 인터페이스 구현 등)

## 3. **다른 방식의 구현 가능성**
- 다른 방식으로도 구현 가능한지 여부
- 가능하다면 **왜** 가능한지(예: 자바의 다형성, 다양한 라이브러리 지원 등)

## 4. **데이터 타입의 위상**
- 해당 구문이 클래스, 메서드, 변수, 키워드, 함수(내장/사용자정의) 등 어떤 위상인지
- 필요하다면 주석에 포함, 아니면 별도로 명시

---

### 예시 (적용 방식)

```java
// [이유/동기] 반복적인 getter/setter 코드를 줄여 가독성과 유지보수성을 높이기 위해 Lombok 라이브러리 사용을 고려할 수 있음.
// [변경 가능성] 변수명, 필드명 등은 자유롭게 변경 가능(코딩 컨벤션에 따라 다름).
// [다른 방식] 직접 getter/setter를 작성하거나, Lombok의 @Getter/@Setter 어노테이션을 사용할 수도 있음.
// [타입 위상] 클래스: TodoDTO, 필드: tno(Long), title(String), dueDate(LocalDate), finished(boolean)
public class TodoDTO {
    private Long tno;      // [필드] 변경 가능(필드명, 타입 등), 목적에 따라 다양한 타입 사용 가능
    private String title;  // [필드] 변경 가능, 제목이 아닌 다른 속성명으로도 사용 가능
    // ...
}
```

---

### 실제 코드 작성 시 적용 예시

- **주석**: 위 기준에 따라 이유, 변경 가능성, 대안, 필요시 타입 위상까지 포함
- **타입 위상**: 코드 블록 아래에 별도 표기(필요시)

---

이런 방식으로 앞으로 코드와 주석을 작성/추출해드리겠습니다.  
특정 코드에 대해 예시가 필요하시거나, 바로 적용해보고 싶은 코드가 있다면 말씀해 주세요!

```java
// [이유/동기] 반복적인 getter/setter 코드를 줄여 가독성과 유지보수성을 높이기 위해 Lombok 라이브러리 사용을 고려할 수 있음.
// [변경 가능성] 변수명, 필드명 등은 자유롭게 변경 가능(코딩 컨벤션에 따라 다름).
// [다른 방식] 직접 getter/setter를 작성하거나, Lombok의 @Getter/@Setter 어노테이션을 사용할 수도 있음.
// [타입 위상] 클래스: TodoDTO, 필드: tno(Long), title(String), dueDate(LocalDate), finished(boolean)
public class TodoDTO {
    private Long tno;      // [필드] 변경 가능(필드명, 타입 등), 목적에 따라 다양한 타입 사용 가능
    private String title;  // [필드] 변경 가능, 제목이 아닌 다른 속성명으로도 사용 가능
    // ...
}
```

---

**User**

그럼 여기도 한번 다시 작업해보자. 여기에 기능 또는 자질이라는 요소도 추가하면 좋겠어. 예를 들어 해당 목적이나 문제 해결, 이유 등이 어떤 '힘'에 기반을 하고 있을 거 아냐(간결성이라든가 유지보수 용이성이라든가 안정성 등등) 이것도 기재하면 좋겠네. 그리고 타입 위상에 [변경 가능성] 부분을 합쳐서 서술 해주면 좋겠어. 그리고 거기에 종속되거나 연관된 내용들은 별도로 기재해주면 좋겠고. 할 수 있지?? 해봐

---

**Cursor**

```java
package com.busanit501.hello_project._2todo.dto;

import java.time.LocalDate;

// [목적/이유] Todo 항목의 데이터 전달을 위한 객체. Controller-View-Model 계층 간 데이터 이동의 표준화. [기능/자질: 계층 분리, 재사용성, 유지보수 용이성] [타입 위상/변경 가능성: 클래스, DTO 패턴, 이름/구조/필드 자유롭게 변경 가능]
public class TodoDTO {
    // [목적/이유] Todo의 고유 식별자 저장. DB의 PK와 매핑. [기능/자질: 데이터 일관성, 식별성] [타입 위상/변경 가능성: 필드, Long, 이름/타입 변경 가능]
    private Long tno;
    // [목적/이유] Todo의 제목 정보 저장. [기능/자질: 가독성, 사용자 편의] [타입 위상/변경 가능성: 필드, String, 이름/타입/제약 변경 가능]
    private String title;
    // [목적/이유] Todo의 마감일 정보 저장. [기능/자질: 시간 관리, 일정 추적] [타입 위상/변경 가능성: 필드, LocalDate, 이름/타입 변경 가능]
    private LocalDate dueDate;
    // [목적/이유] Todo의 완료 여부 저장. [기능/자질: 상태 추적, 논리적 명확성] [타입 위상/변경 가능성: 필드, boolean, 이름/타입 변경 가능]
    private boolean finished;

    // **BEFORE**: 반자동으로 생성.
    // **BEFORE**: 1) 멤법 선택 후, 반자동 생성. 먼저 이것 부터. 작업.
    // **BEFORE**: 2) lombok 라이브러리, 메모리에 자동생성
    // [목적/이유] 반복적인 getter/setter, 생성자, toString 코드 자동화로 생산성 및 일관성 향상. [기능/자질: 간결성, 생산성, 오류 감소] [타입 위상/변경 가능성: 메서드, 자동 생성/직접 작성/라이브러리 활용 모두 가능]
    // [연관/종속] Lombok(@Getter/@Setter 등) 또는 IDE 자동 생성 기능과 연계 가능

    // [목적/이유] tno 값 반환. [기능/자질: 캡슐화, 데이터 접근] [타입 위상/변경 가능성: 메서드, getter, 이름/반환타입 변경 가능]
    public Long getTno() {
        return tno;
    }

    // [목적/이유] tno 값 설정. [기능/자질: 캡슐화, 데이터 수정] [타입 위상/변경 가능성: 메서드, setter, 이름/파라미터 변경 가능]
    public void setTno(Long tno) {
        this.tno = tno;
    }

    // [목적/이유] title 값 반환. [기능/자질: 캡슐화, 데이터 접근] [타입 위상/변경 가능성: 메서드, getter, 이름/반환타입 변경 가능]
    public String getTitle() {
        return title;
    }

    // [목적/이유] title 값 설정. [기능/자질: 캡슐화, 데이터 수정] [타입 위상/변경 가능성: 메서드, setter, 이름/파라미터 변경 가능]
    public void setTitle(String title) {
        this.title = title;
    }

    // [목적/이유] dueDate 값 반환. [기능/자질: 캡슐화, 데이터 접근] [타입 위상/변경 가능성: 메서드, getter, 이름/반환타입 변경 가능]
    public LocalDate getDueDate() {
        return dueDate;
    }

    // [목적/이유] dueDate 값 설정. [기능/자질: 캡슐화, 데이터 수정] [타입 위상/변경 가능성: 메서드, setter, 이름/파라미터 변경 가능]
    public void setDueDate(LocalDate dueDate) {
        this.dueDate = dueDate;
    }

    // [목적/이유] finished 값 반환. [기능/자질: 캡슐화, 데이터 접근] [타입 위상/변경 가능성: 메서드, getter, 이름/반환타입 변경 가능]
    public boolean isFinished() {
        return finished;
    }

    // [목적/이유] finished 값 설정. [기능/자질: 캡슐화, 데이터 수정] [타입 위상/변경 가능성: 메서드, setter, 이름/파라미터 변경 가능]
    public void setFinished(boolean finished) {
        this.finished = finished;
    }

    // [목적/이유] 객체의 모든 필드값을 문자열로 표현. [기능/자질: 디버깅, 로깅, 가독성] [타입 위상/변경 가능성: 메서드, 오버라이드, 내용/형식/출력방식 변경 가능]
    @Override
    public String toString() {
        return "TodoDTO{" +
                "tno=" + tno +
                ", title='" + title + '\'' +
                ", dueDate=" + dueDate +
                ", finished=" + finished +
                '}';
    }

    // [목적/이유] 모든 필드를 초기화하는 생성자. [기능/자질: 객체 일관성, 편의성] [타입 위상/변경 가능성: 생성자, 파라미터/로직/접근제어자 변경 가능]
    public TodoDTO(Long tno, String title, LocalDate dueDate, boolean finished) {
        this.tno = tno;
        this.title = title;
        this.dueDate = dueDate;
        this.finished = finished;
    }

    // [목적/이유] 기본 생성자. [기능/자질: 프레임워크/라이브러리 호환성, 직렬화 지원] [타입 위상/변경 가능성: 생성자, 내용/접근제어자 변경 가능]
    public TodoDTO() {}
}

```

요청하신 기준에 따라 주석을 다음과 같이 정비했습니다.

---

- **[목적/이유]**: 해당 코드가 왜 필요한지, 어떤 문제를 해결하는지, 어떤 동기에서 작성됐는지
- **[기능/자질]**: 간결성, 유지보수성, 안정성, 재사용성 등 해당 코드가 가지는 장점이나 힘
- **[타입 위상/변경 가능성]**: 클래스/필드/메서드/생성자 등 위상과, 이름·타입·구조 등 변경 가능성
- **[연관/종속]**: 다른 코드나 라이브러리와의 연관성(필요시)

---

이제 이 파일은 각 코드 요소의 목적, 장점, 타입 위상, 변경 가능성, 연관성까지 한눈에 파악할 수 있습니다.  
이런 방식으로 앞으로도 주석을 작성해드릴 수 있습니다!  
다른 파일이나 코드에도 적용 원하시면 말씀해 주세요.

---

**User**

응, 잘했는데 코드 구문에 명령하는 부분은 누락되어있네. 지금 말한 것들을 포괄하되, 코드에 명령하는 부분도 넣어줘야해. 앞에서 했던 거 기억하지. 대사처럼 코드에 주석으로 정의한다거나 명령하는 부분 서술되어있었잖아

---

**Cursor**

네, 이해했습니다!  
앞서 말씀하신 것처럼,  
- **코드에 명령하는 부분**(예: “Todo의 고유 식별자를 저장하라”, “getter를 만들어라”, “모든 필드를 초기화하라” 등)  
- 그리고 **대사처럼 명확하게 동작을 지시**하는 주석  
을 포함해서,  
- 목적/이유, 기능/자질, 타입 위상/변경 가능성, 연관/종속  
까지 모두 포괄하는 주석 스타일로 다시 작성하겠습니다.

---

### 예시 스타일

```java
// Todo의 고유 식별자를 저장하라.
// [목적/이유] ... [기능/자질: ...] [타입 위상/변경 가능성: ...]
private Long tno;
```

---

이 기준으로 `TodoDTO.java` 전체를 다시 주석 처리하겠습니다.

```java
// Todo의 고유 식별자를 저장하라.
// [목적/이유] ... [기능/자질: ...] [타입 위상/변경 가능성: ...]
private Long tno;
```

```java
package com.busanit501.hello_project._2todo.dto;

import java.time.LocalDate;

// Todo 항목의 데이터 전달 객체로 정의하라.
// [목적/이유] Todo 항목의 데이터 전달을 위한 객체. Controller-View-Model 계층 간 데이터 이동의 표준화.
// [기능/자질: 계층 분리, 재사용성, 유지보수 용이성]
// [타입 위상/변경 가능성: 클래스, DTO 패턴, 이름/구조/필드 자유롭게 변경 가능]
public class TodoDTO {
    // Todo의 고유 식별자를 저장하라.
    // [목적/이유] Todo의 고유 식별자 저장. DB의 PK와 매핑.
    // [기능/자질: 데이터 일관성, 식별성]
    // [타입 위상/변경 가능성: 필드, Long, 이름/타입 변경 가능]
    private Long tno;
    // Todo의 제목을 저장하라.
    // [목적/이유] Todo의 제목 정보 저장.
    // [기능/자질: 가독성, 사용자 편의]
    // [타입 위상/변경 가능성: 필드, String, 이름/타입/제약 변경 가능]
    private String title;
    // Todo의 마감일을 저장하라.
    // [목적/이유] Todo의 마감일 정보 저장.
    // [기능/자질: 시간 관리, 일정 추적]
    // [타입 위상/변경 가능성: 필드, LocalDate, 이름/타입 변경 가능]
    private LocalDate dueDate;
    // Todo의 완료 여부를 저장하라.
    // [목적/이유] Todo의 완료 여부 저장.
    // [기능/자질: 상태 추적, 논리적 명확성]
    // [타입 위상/변경 가능성: 필드, boolean, 이름/타입 변경 가능]
    private boolean finished;

    // **BEFORE**: 반자동으로 생성.
    // **BEFORE**: 1) 멤법 선택 후, 반자동 생성. 먼저 이것 부터. 작업.
    // **BEFORE**: 2) lombok 라이브러리, 메모리에 자동생성
    // 반복적인 getter/setter, 생성자, toString 코드를 자동 생성하라.
    // [목적/이유] 반복적인 getter/setter, 생성자, toString 코드 자동화로 생산성 및 일관성 향상.
    // [기능/자질: 간결성, 생산성, 오류 감소]
    // [타입 위상/변경 가능성: 메서드, 자동 생성/직접 작성/라이브러리 활용 모두 가능]
    // [연관/종속] Lombok(@Getter/@Setter 등) 또는 IDE 자동 생성 기능과 연계 가능

    // tno 값을 반환하는 getter를 만들어라.
    // [목적/이유] tno 값 반환.
    // [기능/자질: 캡슐화, 데이터 접근]
    // [타입 위상/변경 가능성: 메서드, getter, 이름/반환타입 변경 가능]
    public Long getTno() {
        return tno;
    }

    // tno 값을 설정하는 setter를 만들어라.
    // [목적/이유] tno 값 설정.
    // [기능/자질: 캡슐화, 데이터 수정]
    // [타입 위상/변경 가능성: 메서드, setter, 이름/파라미터 변경 가능]
    public void setTno(Long tno) {
        this.tno = tno;
    }

    // title 값을 반환하는 getter를 만들어라.
    // [목적/이유] title 값 반환.
    // [기능/자질: 캡슐화, 데이터 접근]
    // [타입 위상/변경 가능성: 메서드, getter, 이름/반환타입 변경 가능]
    public String getTitle() {
        return title;
    }

    // title 값을 설정하는 setter를 만들어라.
    // [목적/이유] title 값 설정.
    // [기능/자질: 캡슐화, 데이터 수정]
    // [타입 위상/변경 가능성: 메서드, setter, 이름/파라미터 변경 가능]
    public void setTitle(String title) {
        this.title = title;
    }

    // dueDate 값을 반환하는 getter를 만들어라.
    // [목적/이유] dueDate 값 반환.
    // [기능/자질: 캡슐화, 데이터 접근]
    // [타입 위상/변경 가능성: 메서드, getter, 이름/반환타입 변경 가능]
    public LocalDate getDueDate() {
        return dueDate;
    }

    // dueDate 값을 설정하는 setter를 만들어라.
    // [목적/이유] dueDate 값 설정.
    // [기능/자질: 캡슐화, 데이터 수정]
    // [타입 위상/변경 가능성: 메서드, setter, 이름/파라미터 변경 가능]
    public void setDueDate(LocalDate dueDate) {
        this.dueDate = dueDate;
    }

    // finished 값을 반환하는 getter를 만들어라.
    // [목적/이유] finished 값 반환.
    // [기능/자질: 캡슐화, 데이터 접근]
    // [타입 위상/변경 가능성: 메서드, getter, 이름/반환타입 변경 가능]
    public boolean isFinished() {
        return finished;
    }

    // finished 값을 설정하는 setter를 만들어라.
    // [목적/이유] finished 값 설정.
    // [기능/자질: 캡슐화, 데이터 수정]
    // [타입 위상/변경 가능성: 메서드, setter, 이름/파라미터 변경 가능]
    public void setFinished(boolean finished) {
        this.finished = finished;
    }

    // 객체의 모든 필드값을 문자열로 표현하는 toString 메서드를 오버라이드하라.
    // [목적/이유] 객체의 모든 필드값을 문자열로 표현.
    // [기능/자질: 디버깅, 로깅, 가독성]
    // [타입 위상/변경 가능성: 메서드, 오버라이드, 내용/형식/출력방식 변경 가능]
    @Override
    public String toString() {
        return "TodoDTO{" +
                "tno=" + tno +
                ", title='" + title + '\'' +
                ", dueDate=" + dueDate +
                ", finished=" + finished +
                '}';
    }

    // 모든 필드를 초기화하는 생성자를 만들어라.
    // [목적/이유] 모든 필드를 초기화하는 생성자.
    // [기능/자질: 객체 일관성, 편의성]
    // [타입 위상/변경 가능성: 생성자, 파라미터/로직/접근제어자 변경 가능]
    public TodoDTO(Long tno, String title, LocalDate dueDate, boolean finished) {
        this.tno = tno;
        this.title = title;
        this.dueDate = dueDate;
        this.finished = finished;
    }

    // 기본 생성자를 만들어라.
    // [목적/이유] 기본 생성자.
    // [기능/자질: 프레임워크/라이브러리 호환성, 직렬화 지원]
    // [타입 위상/변경 가능성: 생성자, 내용/접근제어자 변경 가능]
    public TodoDTO() {}
}

```

이제 각 필드, 메서드, 생성자, 클래스 선언부에  
**“명령하는 주석(대사처럼 동작을 지시)”**를 첫 줄에 추가하고,  
그 아래에 목적/이유, 기능/자질, 타입 위상/변경 가능성, 연관/종속 등  
구체적이고 체계적으로 주석을 작성했습니다.

이 방식은  
- **코드의 역할을 명확히 파악**할 수 있고  
- **왜 이렇게 작성했는지, 어떤 힘(특징/장점)에 기반했는지**  
- **변경 가능성, 타입 위상, 연관성**까지 한눈에 볼 수 있습니다.

이런 스타일로 앞으로도 주석을 작성해드릴 수 있습니다!  
다른 파일이나 코드에도 적용 원하시면 언제든 말씀해 주세요.

---

**User**

이런 구문 표현방식을 우리는 어떻게 명명하면 좋을까? 지금과 같은 형태를 띠는 것 말이야.

